<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Home Intelligence Center</title>
    <style>
        :root {
            --dark-bg: #1e1e1e;
            --panel-bg: #2d2d2d;
            --accent-color: #0078d7;
            --text-color: #e0e0e0;
            --success-color: #00cc00;
            --warning-color: #ff5555;
            --humidity-color: #55FFFF;
            --light-color: #FFFF55;
            --temp-color: #FF5555;
            --border-radius: 6px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--dark-bg);
            color: var(--text-color);
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 300px 1fr;
            grid-gap: 20px;
            height: calc(100vh - 100px);
            min-height: 800px; /* Ensure minimum height */
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 10px 0;
        }

        .header h1 {
            font-size: 24px;
            font-weight: bold;
        }

        .connection-status {
            display: flex;
            align-items: center;
        }

        .status-indicator {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .disconnected {
            background-color: var(--warning-color);
        }

        .connected {
            background-color: var(--success-color);
        }

        .panel {
            background-color: var(--panel-bg);
            border-radius: var(--border-radius);
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            min-height: 50px;
        }

        .panel-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .left-column {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .system-control {
            margin-bottom: 10px;
        }

        .power-button {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .btn {
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-power {
            background-color: #333;
            color: white;
            width: 120px;
        }

        .btn-power.on {
            background-color: var(--accent-color);
        }

        .power-status {
            margin-left: 15px;
            font-weight: bold;
        }

        .status-off {
            color: var(--warning-color);
        }

        .status-on {
            color: var(--success-color);
        }

        .divider {
            height: 1px;
            background-color: rgba(255, 255, 255, 0.1);
            margin: 15px 0;
        }

        .control-row {
            margin-bottom: 20px;
        }

        .control-row label {
            display: block;
            margin-bottom: 8px;
        }

        .control-row select {
            padding: 8px;
            border-radius: 4px;
            background-color: #333;
            color: white;
            border: 1px solid #555;
        }

        .slider-container {
            margin-bottom: 15px;
        }

        .slider-label {
            display: block;
            margin-bottom: 8px;
        }

        .slider-control {
            display: flex;
            align-items: center;
        }

        .slider {
            flex-grow: 1;
            height: 5px;
            background: #555;
            outline: none;
            -webkit-appearance: none;
            margin-right: 10px;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
        }

        .slider-value {
            background-color: #222;
            color: #00FF00;
            padding: 5px 10px;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            min-width: 80px;
            text-align: center;
        }

        .button-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn-primary {
            background-color: var(--accent-color);
            color: white;
            flex: 1;
        }

        .btn-secondary {
            background-color: #555;
            color: white;
            flex: 1;
        }

        .system-status {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        .status-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .timestamp {
            font-family: 'Consolas', monospace;
            color: #aaa;
        }

        .log-container {
            flex-grow: 0; /* Change from 1 to 0 to prevent expanding */
            height: 300px; /* Set a fixed height */
            max-height: 300px; /* Ensure maximum height */
            background-color: #222;
            border-radius: 4px;
            padding: 10px;
            overflow-y: auto;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            scroll-behavior: smooth; /* Add smooth scrolling */
        }

        /* Add this class to ensure the system-status panel has proper layout */
        .system-status {
            display: flex;
            flex-direction: column;
            height: 450px; /* Set a fixed height */
        }

        .log-entry {
            margin-bottom: 5px;
        }

        .log-timestamp {
            color: #aaa;
        }

        .log-alert {
            color: var(--warning-color);
        }

        .right-column {
            display: grid;
            grid-template-rows: minmax(1000px, auto) minmax(150px, auto);
            gap: 15px;
            height: 100%;
        }

        .prediction-results {
            display: grid;
            grid-template-rows: auto auto auto 260px;  /* Header, time info, prediction values, charts */
            gap: 0; 
            max-height: calc(150vh - 100px); /* Match container height */
            overflow: hidden; /* Prevent overflow */
            overflow: hidden; /* Prevent overflow */
        }


        .time-info {
            height: auto;
            min-height: 40px;
        }

        .time-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .time-label {
            font-weight: bold;
        }

        .time-value {
            font-family: 'Consolas', monospace;
        }

        .prediction-values {
            height: auto;
            min-height: 80px; 
            margin-bottom: 0px;
            padding-bottom: 0px;
        }

        .prediction-title {
            text-align: center;
            font-size: 20px;
            margin-bottom: 8px;
        }

        .prediction-row {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            padding-bottom: 0px; /* Ensure no extra padding */
        }

        /* Make the last prediction row have no bottom margin */
        .prediction-row:last-child {
            margin-bottom: 0;
        }   

        .prediction-icon {
            font-size: 24px;
            margin-right: 15px;
            width: 40px;
            text-align: center;
        }

        .prediction-label {
            font-size: 16px;
            width: 120px;
        }

        .prediction-unit {
            margin-left: auto;
            margin-right: 10px;
        }

        .prediction-value {
            background-color: #222;
            padding: 10px 15px;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            font-size: 24px;
            font-weight: bold;
            min-width: 100px;
            text-align: center;
        }

        .temp-value {
            color: var(--temp-color);
        }

        .humidity-value {
            color: var(--humidity-color);
        }

        .light-value {
            color: var(--light-color);
        }

        .device-status {
            height: auto;
            min-height: 110px;
        }

        .device-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .device-icon {
            font-size: 18px;
            margin-right: 15px;
            width: 25px;
            text-align: center;
        }

        .device-label {
            font-size: 14px;
            flex-grow: 1;
        }

        .device-status-value {
            font-weight: bold;
            width: 50px;
            text-align: right;
            transition: color 0.3s ease;
        }

        /* Make the lower panels container fixed size */
        .lower-panels {
            display: grid;
            grid-template-rows: auto auto;
            gap: 15px;
            height: fit-content;
            min-height: 250px;
        }

        .status-on-text {
            color: var(--success-color);
        }

           /* Ensure charts container has fixed height */
        .charts-container {
            height: 480px;
            display: grid;
            grid-template-rows: 1fr 1fr 1fr;  /* Equal height for each chart */
            gap: 5px;  /* Small gap between charts */
            overflow: hidden;
            margin-bottom: 20px;  /* Space between charts and lower panels */
            margin-top: -5px; /* Added small margin at top */
            border-top: none; /* 1px solid rgba(255, 255, 255, 0.1); /* Optional: subtle divider */
            padding-top: 10px; /* Padding at the top */
        }
        
        /* Ensure each chart stays in its container */
        .chart {
            width: 100% !important;
            height: 100% !important;
            position: relative;
            max-height: none; 
        }

        .alert-panel {
            height: auto;
            min-height: 30px;
            background-color: var(--panel-bg);
            border-radius: var(--border-radius);
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .alert-text {
            text-align: center;
            font-weight: bold;
            font-size: 15px;
        }

        .alert-success {
            color: var(--success-color);
        }

        .alert-warning {
            color: var(--warning-color);
        }

        .chart-wrapper {
            position: relative;
            height: 100%;
            width: 100%;
            overflow: visible;
            padding: 4px 0; /* Slightly more padding */
            box-sizing: border-box;
            min-height: 150px; /* Ensure minimum height */
        }

        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>SMART HOME INTELLIGENCE CENTER</h1>
        <div class="connection-status">
            <div id="connectionIndicator" class="status-indicator disconnected"></div>
            <span id="connectionText">DISCONNECTED</span>
        </div>
    </div>

    <div class="container">
        <div class="left-column">
            <div class="panel">
                <div class="panel-title">System Control</div>
                <div class="system-control">
                    <div class="power-button">
                        <button id="powerBtn" class="btn btn-power">POWER</button>
                        <span id="powerStatus" class="power-status status-off">OFF</span>
                    </div>

                    <div class="divider"></div>

                    <div class="control-row">
                        <label for="forecastDuration">Forecast Duration:</label>
                        <select id="forecastDuration">
                            <option value="5">5 minutes</option>
                            <option value="10">10 minutes</option>
                            <option value="15">15 minutes</option>
                            <option value="20">20 minutes</option>
                            <option value="25">25 minutes</option>
                            <option value="30" selected>30 minutes</option>
                            <option value="35">35 minutes</option>
                            <option value="40">40 minutes</option>
                            <option value="45">45 minutes</option>
                            <option value="50">50 minutes</option>
                            <option value="55">55 minutes</option>
                            <option value="60">60 minutes</option>
                        </select>
                    </div>

                    <div class="divider"></div>

                    <div class="control-row">
                        <label for="forecastInterval">Forecast Interval:</label>
                        <select id="forecastInterval">
                            <option value="1">1 minute</option>
                            <option value="3" selected>3 minutes</option>
                            <option value="5">5 minutes</option>
                            <option value="10">10 minutes</option>
                            <option value="20">20 minutes</option>
                            <option value="30">30 minutes</option>
                            <option value="40">40 minutes</option>
                            <option value="50">50 minutes</option>
                            <option value="60">60 minutes</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-title">Environmental Thresholds</div>
                
                <div class="slider-container">
                    <span class="slider-label">Temperature Threshold:</span>
                    <div class="slider-control">
                        <input type="range" min="15" max="35" value="25" step="0.1" class="slider" id="tempSlider">
                        <div class="slider-value" id="tempValue">25.0 °C</div>
                    </div>
                </div>

                <div class="slider-container">
                    <span class="slider-label">Humidity Threshold:</span>
                    <div class="slider-control">
                        <input type="range" min="30" max="90" value="60" step="0.1" class="slider" id="humiditySlider">
                        <div class="slider-value" id="humidityValue">60.0 %</div>
                    </div>
                </div>

                <div class="slider-container">
                    <span class="slider-label">Light Threshold:</span>
                    <div class="slider-control">
                        <input type="range" min="0" max="1000" value="500" step="0.1" class="slider" id="lightSlider">
                        <div class="slider-value" id="lightValue">500.0 Lux</div>
                    </div>
                </div>

                <div class="button-row">
                    <button id="applyBtn" class="btn btn-primary">Apply Settings</button>
                    <button id="restoreBtn" class="btn btn-secondary">Restore Defaults</button>
                </div>
            </div>

            <div class="panel system-status">
                <div class="panel-title">System Status</div>
                
                <div class="status-header">
                    <span>Last Updated:</span>
                    <span id="lastUpdateTime" class="timestamp">--</span>
                </div>
                
                <div class="status-header">
                    <span>Next Forecast:</span>
                    <span id="nextForecastTime" class="timestamp">--</span>
                </div>
                
                <div class="divider"></div>
                <span>Event Log:</span>
                <div id="logContainer" class="log-container"></div>
            </div>
        </div>

        <!-- Replace the right-column div structure (around line 491) -->

    <div class="right-column">
        <div class="panel prediction-results">
            <div class="panel-title">Prediction Results</div>
            <div class="time-info">
                <div class="time-row">
                    <span class="time-label">Current Time:</span>
                    <span id="currentTime" class="time-value">--</span>
                </div>
                <div class="time-row">
                    <span class="time-label">Forecast Time:</span>
                    <span id="forecastTime" class="time-value">--</span>
                </div>
                <div class="time-row">
                    <span class="time-label">Prediction Timeframe:</span>
                    <span id="timeframe" class="time-value">--</span>
                </div>
            </div>

            <div class="divider"></div>

            <div class="prediction-values">
                <div class="prediction-title">PREDICTED ENVIRONMENTAL VALUES</div>
                
                <div class="prediction-row">
                    <div class="prediction-icon">🌡</div>
                    <div class="prediction-label">Temperature</div>
                    <div class="prediction-unit">°C</div>
                    <div id="tempPrediction" class="prediction-value temp-value">--</div>
                </div>
                
                <div class="prediction-row">
                    <div class="prediction-icon">💧</div>
                    <div class="prediction-label">Humidity</div>
                    <div class="prediction-unit">%</div>
                    <div id="humidityPrediction" class="prediction-value humidity-value">--</div>
                </div>
                
                <div class="prediction-row">
                    <div class="prediction-icon">💡</div>
                    <div class="prediction-label">Light</div>
                    <div class="prediction-unit">Lux</div>
                    <div id="lightPrediction" class="prediction-value light-value">--</div>
                </div>
            </div>

            <div class="charts-container">
                <div class="chart-wrapper">
                    <canvas id="tempChart" class="chart"></canvas>
                </div>
                <div class="chart-wrapper">
                    <canvas id="humidityChart" class="chart"></canvas>
                </div>
                <div class="chart-wrapper">
                    <canvas id="lightChart" class="chart"></canvas>
                </div>
            </div>
        </div>

        <!-- Lower panels in their own container -->
        <div class="lower-panels">
            <div class="panel device-status">
                <div class="panel-title">Smart Device Status</div>
                
                <div class="device-row">
                    <div class="device-icon">❄</div>
                    <div class="device-label">Air Conditioner:</div>
                    <div id="acStatus" class="device-status-value">OFF</div>
                </div>
                
                <div class="device-row">
                    <div class="device-icon">💡</div>
                    <div class="device-label">Lights:</div>
                    <div id="lightsStatus" class="device-status-value">OFF</div>
                </div>
                
                <div class="device-row">
                    <div class="device-icon">💧</div>
                    <div class="device-label">Humidity:</div>
                    <div id="humidityStatus" class="device-status-value">OFF</div>
                </div>
            </div>

            <div class="alert-panel">
                <div id="alertText" class="alert-text alert-success">All values within threshold limits</div>
            </div>
        </div>
    </div>

    <!-- Replace your existing script tags with these: -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.1.2/dist/chartjs-plugin-annotation.min.js"></script>
    <script>
        // State management
        const appState = {
            system: {
                power: false,
                connected: false,
                forecastMinutes: 30,
                forecastInterval: 3,
                lastUpdate: null,
                nextForecast: null
            },
            thresholds: {
                temperature: 25.0,
                humidity: 60.0,
                light: 500.0
            },
            predictions: {
                temperature: null,
                humidity: null,
                light: null,
                timestamps: [],
                temperatureData: [],
                humidityData: [],
                lightData: []
            },
            devices: {
                airConditioner: "OFF",
                lights: "OFF",
                moistureAbsorber: "OFF"
            },
            logs: [],
            charts: {
                temperature: null,
                humidity: null,
                light: null
            }
        };

        // API URL
        // To use the actual server IP:
        const API_URL = window.location.origin;

        // Dom Elements
        const elements = {
            connectionIndicator: document.getElementById("connectionIndicator"),
            connectionText: document.getElementById("connectionText"),
            powerBtn: document.getElementById("powerBtn"),
            powerStatus: document.getElementById("powerStatus"),
            forecastDuration: document.getElementById("forecastDuration"),
            forecastInterval: document.getElementById("forecastInterval"),
            tempSlider: document.getElementById("tempSlider"),
            tempValue: document.getElementById("tempValue"),
            humiditySlider: document.getElementById("humiditySlider"),
            humidityValue: document.getElementById("humidityValue"),
            lightSlider: document.getElementById("lightSlider"),
            lightValue: document.getElementById("lightValue"),
            applyBtn: document.getElementById("applyBtn"),
            restoreBtn: document.getElementById("restoreBtn"),
            lastUpdateTime: document.getElementById("lastUpdateTime"),
            nextForecastTime: document.getElementById("nextForecastTime"),
            logContainer: document.getElementById("logContainer"),
            currentTime: document.getElementById("currentTime"),
            forecastTime: document.getElementById("forecastTime"),
            timeframe: document.getElementById("timeframe"),
            tempPrediction: document.getElementById("tempPrediction"),
            humidityPrediction: document.getElementById("humidityPrediction"),
            lightPrediction: document.getElementById("lightPrediction"),
            acStatus: document.getElementById("acStatus"),
            lightsStatus: document.getElementById("lightsStatus"),
            humidityStatus: document.getElementById("humidityStatus"),
            alertText: document.getElementById("alertText"),
            tempChart: document.getElementById("tempChart"),
            humidityChart: document.getElementById("humidityChart"),
            lightChart: document.getElementById("lightChart")
        };

        function registerChartPlugins() {
            try {
                console.log("Registering Chart.js plugins...");
                
                // Confirm Chart.js is loaded
                if (typeof Chart === 'undefined') {
                    console.error("Chart.js is not loaded!");
                    return false;
                }
                
                // For Chart.js v3, annotations are now a separate plugin
                // Check if chartjs-plugin-annotation is loaded
                if (typeof Chart.annotation !== 'undefined' || typeof window.ChartAnnotation !== 'undefined') {
                    // Register the plugin based on how it's exposed
                    if (typeof Chart.annotation !== 'undefined') {
                        console.log("Using Chart.annotation");
                    } else if (typeof window.ChartAnnotation !== 'undefined') {
                        Chart.register(window.ChartAnnotation);
                        console.log("Registered ChartAnnotation from window object");
                    }
                } else {
                    console.warn("Chart.js Annotation plugin not found - continuing without annotations");
                    // We'll continue without annotations
                }
                
                return true;
            } catch (e) {
                console.error("Error registering plugins:", e);
                return false;
            }
        }
        // Initialize charts
        function initCharts() {
            try {
                // Temperature chart
                const tempCtx = document.getElementById('tempChart').getContext('2d');
                if (!tempCtx) {
                    console.error("Temperature chart canvas context not found");
                    return;
                }
                
                // Create basic options first
                const tempOptions = {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 0 // Disable animation for faster updates 
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Temperature Forecast',
                            color: 'white',
                            font: {
                                size: 12 // Smaller title
                            }
                        },
                        legend: {
                            display: false // Hide legend to save space
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false, // Don't force starting at zero
                            grace: '10%',
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: 'white',
                                font: {
                                    size: 11 // Smaller ticks
                                },
                                maxTicksLimit: 6
                            },
                            title: { 
                                display: true, 
                                text: '°C', 
                                color: 'white',
                                font: {
                                    size: 10 // Smaller title
                                }
                            }
                        },
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: 'white',
                                font: {
                                    size: 9 // Smaller ticks
                                },
                                maxRotation: 45, // Rotate labels for better fit
                                minRotation: 45
                            }
                        }
                    }
                };
                    
                    // Only add annotations if supported
                    if (Chart.Annotation) {
                        tempOptions.plugins.annotation = {
                            annotations: {
                                threshold: {
                                    type: 'line',
                                    yMin: appState.thresholds.temperature,
                                    yMax: appState.thresholds.temperature,
                                    borderColor: 'white',
                                    borderWidth: 1,
                                    borderDash: [5, 5]
                                }
                            }
                        };
                    }
                    
                    // Create the chart
                    appState.charts.temperature = new Chart(tempCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Temperature',
                                data: [],
                                borderColor: '#FF5555',
                                backgroundColor: 'rgba(255, 85, 85, 0.2)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.4
                            }]
                        },
                        options: tempOptions
                    });

                    // Humidity chart
                    const humdCtx = document.getElementById('humidityChart').getContext('2d');
                    if (!humdCtx) {
                        console.error("Humidity chart canvas context not found");
                        return;
                    }
                    
                    // Create basic options first
                    const humdOptions = {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: {
                            duration: 0 // Disable animation for faster updates 
                        },
                        plugins: {
                        title: {
                            display: true,
                            text: 'Humidity Forecast',
                            color: 'white',
                            font: {
                                size: 12 // Smaller title
                            }
                        },
                        legend: {
                            display: false // Hide legend to save space
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false, // Don't force starting at zero
                            grace: '10%', // Add 5% padding to the scale
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: 'white',
                                font: {
                                    size: 11 // Smaller ticks
                                },
                                maxTicksLimit: 6
                            },
                            title: { 
                                display: true, 
                                text: '%', 
                                color: 'white',
                                font: {
                                    size: 10 // Smaller title
                                }
                            }
                        },
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: 'white',
                                font: {
                                    size: 9 // Smaller ticks
                                },
                                maxRotation: 45, // Rotate labels for better fit
                                minRotation: 45
                            }
                        }
                    }
                };
                
                // Only add annotations if supported
                if (Chart.Annotation) {
                    humdOptions.plugins.annotation = {
                        annotations: {
                            threshold: {
                                type: 'line',
                                yMin: appState.thresholds.humidity,
                                yMax: appState.thresholds.humidity,
                                borderColor: 'white',
                                borderWidth: 1,
                                borderDash: [5, 5]
                            }
                        }
                    };
                }
                
                // Create the chart
                appState.charts.humidity = new Chart(humdCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Humidity',
                            data: [],
                            borderColor: '#55FFFF',
                            backgroundColor: 'rgba(85, 255, 255, 0.2)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: humdOptions
                });

                // Light chart
                const lightCtx = document.getElementById('lightChart').getContext('2d');
                if (!lightCtx) {
                    console.error("Light chart canvas context not found");
                    return;
                }
                
                // Create basic options first
                const lightOptions = {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 0 // Disable animation for faster updates 
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Light Forecast',
                            color: 'white',
                            font: {
                                size: 12 // Smaller title
                            }
                        },
                        legend: {
                            display: false // Hide legend to save space
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false, // Don't force starting at zero
                            grace: '10%', // Add 5% padding to the scale
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: 'white',
                                font: {
                                    size: 11 // Smaller ticks
                                },
                                maxTicksLimit: 6 
                            },
                            title: { 
                                display: true, 
                                text: 'Lux', 
                                color: 'white',
                                font: {
                                    size: 10 // Smaller title
                                }
                            }
                        },
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: 'white',
                                font: {
                                    size: 9 // Smaller ticks
                                },
                                maxRotation: 45, // Rotate labels for better fit
                                minRotation: 45
                            }
                        }
                    }
                };
                
                // Only add annotations if supported
                if (Chart.Annotation) {
                    lightOptions.plugins.annotation = {
                        annotations: {
                            threshold: {
                                type: 'line',
                                yMin: appState.thresholds.light,
                                yMax: appState.thresholds.light,
                                borderColor: 'white',
                                borderWidth: 1,
                                borderDash: [5, 5]
                            }
                        }
                    };
                }
                
                // Create the chart
                appState.charts.light = new Chart(lightCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Light',
                            data: [],
                            borderColor: '#FFFF55',
                            backgroundColor: 'rgba(255, 255, 85, 0.2)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: lightOptions
                });
                
                // Do the same for other charts...
            } catch (error) {
                console.error("Error initializing charts:", error);
                addLogEntry("Failed to initialize charts: " + error.message);
            }
        }

        // Load settings from localstorage
        function loadSettings() {
            try {
                const settings = localStorage.getItem('smart_home_settings');
                if (settings) {
                    const parsedSettings = JSON.parse(settings);
                    
                    // Update thresholds
                    if (parsedSettings.thresholds) {
                        appState.thresholds = parsedSettings.thresholds;
                        elements.tempSlider.value = appState.thresholds.temperature;
                        elements.tempValue.textContent = `${appState.thresholds.temperature.toFixed(1)} °C`;
                        
                        elements.humiditySlider.value = appState.thresholds.humidity;
                        elements.humidityValue.textContent = `${appState.thresholds.humidity.toFixed(1)} %`;
                        
                        elements.lightSlider.value = appState.thresholds.light;
                        elements.lightValue.textContent = `${appState.thresholds.light.toFixed(1)} Lux`;
                    }
                    
                    // Update forecast minutes
                    if (parsedSettings.forecastMinutes) {
                        appState.system.forecastMinutes = parsedSettings.forecastMinutes;
                        elements.forecastDuration.value = appState.system.forecastMinutes;
                    }
                    
                    // Update forecast interval
                    if (parsedSettings.forecastInterval) {
                        appState.system.forecastInterval = parsedSettings.forecastInterval;
                        elements.forecastInterval.value = appState.system.forecastInterval;
                    }
                    
                    addLogEntry("Settings loaded from storage");
                    return true;
                }
            } catch (error) {
                addLogEntry(`Error loading settings: ${error.message}`);
            }
            
            return false;
        }

        // Save settings to localstorage
        function saveSettings() {
            try {
                const settings = {
                    thresholds: appState.thresholds,
                    forecastMinutes: appState.system.forecastMinutes,
                    forecastInterval: appState.system.forecastInterval
                };
                
                localStorage.setItem('smart_home_settings', JSON.stringify(settings));
                addLogEntry("Settings saved");
            } catch (error) {
                addLogEntry(`Error saving settings: ${error.message}`);
            }
        }

        // Apply settings to backend
        async function applySettings() {
            if (!appState.system.connected) {
                alert("Cannot update settings: Server unreachable");
                return;
            }
            
            try {
                const settings = {
                    thresholds: {
                        Temperature: appState.thresholds.temperature,
                        Humidity: appState.thresholds.humidity,
                        Light: appState.thresholds.light
                    },
                    forecast_minutes: appState.system.forecastMinutes,
                    forecast_interval: appState.system.forecastInterval
                };
                
                const response = await fetch(`${API_URL}/settings`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(settings)
                });
                
                if (response.ok) {
                    addLogEntry("Settings applied successfully");
                    
                    // Update chart thresholds
                    updateChartThresholds();
                } else {
                    const errorText = await response.text();
                    alert(`Failed to update settings: ${errorText}`);
                }
            } catch (error) {
                alert(`Failed to send settings: ${error.message}`);
            }
        }

        // Restore default settings
        function restoreDefaultSettings() {
            // Define default values
            appState.thresholds = {
                temperature: 25.0,
                humidity: 60.0,
                light: 500.0
            };
            appState.system.forecastMinutes = 30;
            appState.system.forecastInterval = 3;
            
            // Update UI elements
            elements.tempSlider.value = appState.thresholds.temperature;
            elements.tempValue.textContent = `${appState.thresholds.temperature.toFixed(1)} °C`;
            
            elements.humiditySlider.value = appState.thresholds.humidity;
            elements.humidityValue.textContent = `${appState.thresholds.humidity.toFixed(1)} %`;
            
            elements.lightSlider.value = appState.thresholds.light;
            elements.lightValue.textContent = `${appState.thresholds.light.toFixed(1)} Lux`;
            
            elements.forecastDuration.value = appState.system.forecastMinutes;
            elements.forecastInterval.value = appState.system.forecastInterval;
            
            // Log and notify
            addLogEntry("Settings restored to defaults");
            alert("Settings have been restored to defaults");
            
            // Save the default settings
            saveSettings();
            applySettings();
        }

        // Update last update time
        function updateLastUpdateTime() {
            const now = new Date();
            appState.system.lastUpdate = now;
            elements.lastUpdateTime.textContent = formatTime(now);
        }

        function updateNextForecastTime() {
            if (!monitoringInterval) {
                elements.nextForecastTime.textContent = "--";
                return;
            }
            
            // Calculate next forecast time
            const intervalMs = appState.system.forecastInterval * 60 * 1000;
            const now = new Date();
            const nextTime = new Date(now.getTime() + intervalMs);
            
            appState.system.nextForecast = nextTime;
            elements.nextForecastTime.textContent = formatTime(nextTime);
        }

        // Update chart thresholds when settings change
        function updateChartThresholds() {
            try {
                // Safety check for temperature chart
                if (appState.charts.temperature) {
                    // Check if annotation plugin is available and properly configured
                    if (appState.charts.temperature.options && 
                        appState.charts.temperature.options.plugins && 
                        appState.charts.temperature.options.plugins.annotation) {
                        
                        // Create annotations object if it doesn't exist
                        if (!appState.charts.temperature.options.plugins.annotation.annotations) {
                            appState.charts.temperature.options.plugins.annotation.annotations = {};
                        }
                        
                        // Create threshold object if it doesn't exist
                        if (!appState.charts.temperature.options.plugins.annotation.annotations.threshold) {
                            appState.charts.temperature.options.plugins.annotation.annotations.threshold = {
                                type: 'line',
                                borderColor: 'white',
                                borderWidth: 1,
                                borderDash: [5, 5]
                            };
                        }
                        
                        // Now safely set the values
                        appState.charts.temperature.options.plugins.annotation.annotations.threshold.yMin = appState.thresholds.temperature;
                        appState.charts.temperature.options.plugins.annotation.annotations.threshold.yMax = appState.thresholds.temperature;
                        appState.charts.temperature.update();
                    } else {
                        console.log("Temperature chart doesn't support annotations, skipping threshold update");
                    }
                }
                
                // Same pattern for humidity chart
                if (appState.charts.humidity) {
                    if (appState.charts.humidity.options && 
                        appState.charts.humidity.options.plugins && 
                        appState.charts.humidity.options.plugins.annotation) {
                        
                        if (!appState.charts.humidity.options.plugins.annotation.annotations) {
                            appState.charts.humidity.options.plugins.annotation.annotations = {};
                        }
                        
                        if (!appState.charts.humidity.options.plugins.annotation.annotations.threshold) {
                            appState.charts.humidity.options.plugins.annotation.annotations.threshold = {
                                type: 'line',
                                borderColor: 'white',
                                borderWidth: 1,
                                borderDash: [5, 5]
                            };
                        }
                        
                        appState.charts.humidity.options.plugins.annotation.annotations.threshold.yMin = appState.thresholds.humidity;
                        appState.charts.humidity.options.plugins.annotation.annotations.threshold.yMax = appState.thresholds.humidity;
                        appState.charts.humidity.update();
                    }
                }
                
                // Same pattern for light chart
                if (appState.charts.light) {
                    if (appState.charts.light.options && 
                        appState.charts.light.options.plugins && 
                        appState.charts.light.options.plugins.annotation) {
                        
                        if (!appState.charts.light.options.plugins.annotation.annotations) {
                            appState.charts.light.options.plugins.annotation.annotations = {};
                        }
                        
                        if (!appState.charts.light.options.plugins.annotation.annotations.threshold) {
                            appState.charts.light.options.plugins.annotation.annotations.threshold = {
                                type: 'line',
                                borderColor: 'white',
                                borderWidth: 1,
                                borderDash: [5, 5]
                            };
                        }
                        
                        appState.charts.light.options.plugins.annotation.annotations.threshold.yMin = appState.thresholds.light;
                        appState.charts.light.options.plugins.annotation.annotations.threshold.yMax = appState.thresholds.light;
                        appState.charts.light.update();
                    }
                }
            } catch (err) {
                console.error("Error updating chart thresholds:", err);
                addLogEntry("Failed to update chart thresholds: " + err.message);
            }
        }

        // Toggle system power
        async function toggleSystem() {
            const newPowerState = !appState.system.power;
            
            if (newPowerState) {
                // Turning ON
                try {
                    const response = await fetch(`${API_URL}/system_status`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ system_on: true })
                    });
                    
                    if (response.ok) {
                        appState.system.power = true;
                        elements.powerStatus.textContent = "ON";
                        elements.powerStatus.className = "power-status status-on";
                        elements.powerBtn.classList.add("on");
                        addLogEntry("System activated");
                        
                        // Start monitoring
                        startMonitoring();
                    } else {
                        const errorText = await response.text();
                        alert(`Failed to turn on system: ${errorText}`);
                    }
                } catch (error) {
                    alert(`Could not connect to server: ${error.message}`);
                }
            } else {
                // Turning OFF
                try {
                    const response = await fetch(`${API_URL}/system_status`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ 
                            system_on: false,
                            turn_off_all_appliances: true
                        })
                    });
                    
                    appState.system.power = false;
                    elements.powerStatus.textContent = "OFF";
                    elements.powerStatus.className = "power-status status-off";
                    elements.powerBtn.classList.remove("on");
                    
                    // Update device status UI immediately
                    elements.acStatus.textContent = "OFF";
                    elements.acStatus.className = "device-status-value";
                    
                    elements.lightsStatus.textContent = "OFF";
                    elements.lightsStatus.className = "device-status-value";
                    
                    elements.humidityStatus.textContent = "OFF";
                    elements.humidityStatus.className = "device-status-value";
                    
                    addLogEntry("System deactivated - All appliances turned off");
                    
                    // Stop monitoring
                    stopMonitoring();
                    
                    if (response.ok) {
                        addLogEntry("All appliances turned off successfully");
                    } else {
                        const errorText = await response.text();
                        addLogEntry(`Failed to turn off all appliances: ${errorText}`);
                    }
                } catch (error) {
                    addLogEntry(`Failed to turn off appliances: ${error.message}`);
                }
            }
        }

        // In your system_health check:
        async function checkSystemHealth() {
            try {
                const response = await fetch(`${API_URL}/system_health?t=${Date.now()}`);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log("System health response:", data);
                    
                    // Update UI based on MQTT connection status
                    updateConnectionStatus(data.mqtt_connected);
                    
                    // Update system power status if needed
                    if (appState.system.power !== data.system_on) {
                        appState.system.power = data.system_on;
                        updatePowerStatus();
                    }
                }
            } catch (error) {
                console.error("Health check failed:", error);
            }
        }

        // Call this every 5 seconds
        setInterval(checkSystemHealth, 5000);

        // In your checkConnection function:
        async function checkConnection() {
            try {
                // Add timestamp to prevent caching
                const response = await fetch(`${API_URL}/status?t=${Date.now()}`);
                
                if (response.ok) {
                    updateConnectionStatus(true);
                } else {
                    updateConnectionStatus(false, "ERROR");
                }
            } catch (error) {
                console.error("Connection check failed:", error);
                updateConnectionStatus(false);
            }
            
            // Schedule next check if not closing
            setTimeout(checkConnection, 5000); // Check more frequently (5s)
        }

        // Update connection status UI
        function updateConnectionStatus(connected, statusText) {
            appState.system.connected = connected;
            
            if (connected) {
                elements.connectionIndicator.className = "status-indicator connected";
                elements.connectionText.textContent = "CONNECTED";
            } else {
                elements.connectionIndicator.className = "status-indicator disconnected";
                elements.connectionText.textContent = statusText || "DISCONNECTED";
            }
        }

        // Monitoring functions
        let monitoringInterval = null;

        function startMonitoring() {
            updateForecast();
            
            // Calculate interval in milliseconds
            const intervalMs = appState.system.forecastInterval * 60 * 1000;
            
            // Clear any existing interval
            if (monitoringInterval) {
                clearInterval(monitoringInterval);
            }
            
            // Set new interval
            monitoringInterval = setInterval(updateForecast, intervalMs);
            
            // Update next forecast time
            updateNextForecastTime();
        }

        function stopMonitoring() {
            if (monitoringInterval) {
                clearInterval(monitoringInterval);
                monitoringInterval = null;
            }
            // Clear next forecast time
            elements.nextForecastTime.textContent = "--";
        }

        // Update forecast data
        async function updateForecast() {
            if (!appState.system.connected || !appState.system.power) {
                return;
            }
            
            try {
                const response = await fetch(`${API_URL}/forecast?minutes=${appState.system.forecastMinutes}`);
                
                if (response.ok) {
                    const forecastData = await response.json();
                    processForecastData(forecastData);
                    updateLastUpdateTime();
                    updateNextForecastTime();
                } else {
                    const errorText = await response.text();
                    addLogEntry(`Failed to get forecast: ${errorText}`);
                }
            } catch (error) {
                addLogEntry(`Forecast error: ${error.message}`);
            }
        }

        // Process forecast data
        function processForecastData(data) {
            // Parse the forecast data
            const timestamps = data.timestamps;
            const temperature = data.temperature;
            const humidity = data.humidity;
            const light = data.light;
            
            // Get device status
            const deviceStatus = data.device_status || {};
            const statusMessages = data.status_messages || [];
            
            // Store data for charts
            appState.predictions.timestamps = timestamps;
            appState.predictions.temperatureData = temperature;
            appState.predictions.humidityData = humidity;
            appState.predictions.lightData = light;
            
            // Get the final prediction values
            const finalIndex = temperature.length - 1;
            appState.predictions.temperature = temperature[finalIndex];
            appState.predictions.humidity = humidity[finalIndex];
            appState.predictions.light = light[finalIndex];
            
            // Update the time displays
            const currentTime = new Date();
            elements.currentTime.textContent = formatDate(currentTime);
            
            // Convert timestamp to date object if it's a string
            let finalTimestamp;
            if (typeof timestamps[finalIndex] === 'string') {
                finalTimestamp = new Date(timestamps[finalIndex]);
            } else {
                finalTimestamp = timestamps[finalIndex];
            }
            
            elements.forecastTime.textContent = formatDate(finalTimestamp);
            elements.timeframe.textContent = `${appState.system.forecastMinutes} minutes`;
            
            // Update prediction values
            elements.tempPrediction.textContent = appState.predictions.temperature.toFixed(1);
            elements.humidityPrediction.textContent = appState.predictions.humidity.toFixed(1);
            elements.lightPrediction.textContent = appState.predictions.light.toFixed(1);
            
            // Update device status
            updateDeviceStatus(deviceStatus);
            
            // Log status messages
            for (const msg of statusMessages) {
                addLogEntry(msg);
            }
            
            // Check threshold status and update alert
            const alerts = [];
            if (appState.predictions.temperature > appState.thresholds.temperature) {
                alerts.push(`Temperature (${appState.predictions.temperature.toFixed(1)}°C) exceeds threshold`);
            }
            if (appState.predictions.humidity > appState.thresholds.humidity) {
                alerts.push(`Humidity (${appState.predictions.humidity.toFixed(1)}%) exceeds threshold`);
            }
            if (appState.predictions.light > appState.thresholds.light) {
                alerts.push(`Light (${appState.predictions.light.toFixed(1)} Lux) exceeds threshold`);
            }
            
            if (alerts.length > 0) {
                const alertText = alerts.join("\n");
                elements.alertText.textContent = alertText;
                elements.alertText.className = "alert-text alert-warning";
                addLogEntry(`Alert: ${alerts.join(", ")}`, true);
            } else {
                elements.alertText.textContent = "All values within threshold limits";
                elements.alertText.className = "alert-text alert-success";
            }

            console.log("Until here")
            
            // Update charts
            updateCharts();
            
            console.log("Until second part")
            
            addLogEntry("Forecast updated successfully");
        }

        // Update device status displays
        function updateDeviceStatus(deviceStatus) {
            // Air conditioner status
            const acStatus = deviceStatus.air_conditioner || "OFF";
            appState.devices.airConditioner = acStatus;
            elements.acStatus.textContent = acStatus;
            
            if (acStatus === "ON") {
                elements.acStatus.className = "device-status-value status-on-text";
            } else {
                elements.acStatus.className = "device-status-value";
            }
            
            // Lights status
            const lightsStatus = deviceStatus.lights || "OFF";
            appState.devices.lights = lightsStatus;
            elements.lightsStatus.textContent = lightsStatus;
            
            if (lightsStatus === "ON") {
                elements.lightsStatus.className = "device-status-value status-on-text";
            } else {
                elements.lightsStatus.className = "device-status-value";
            }
            
            // Moisture absorber status
            const moistureStatus = deviceStatus.moisture_absorber || "OFF";
            appState.devices.moistureAbsorber = moistureStatus;
            elements.humidityStatus.textContent = moistureStatus;
            
            if (moistureStatus === "ON") {
                elements.humidityStatus.className = "device-status-value status-on-text";
            } else {
                elements.humidityStatus.className = "device-status-value";
            }
        }

        function updateCharts() {
            try {
                // Format timestamps for display
                const formattedLabels = appState.predictions.timestamps.map(ts => {
                    if (typeof ts === 'string') {
                        return new Date(ts).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    } else {
                        return ts.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    }
                });
                
                // Temperature chart - prepare data
                if (appState.charts.temperature) {
                    // Set data without animation first
                    appState.charts.temperature.options.animation = false;
                    appState.charts.temperature.data.labels = formattedLabels;
                    appState.charts.temperature.data.datasets[0].data = appState.predictions.temperatureData;
                    appState.charts.temperature.update();
                }
                
                // Humidity chart - prepare data
                if (appState.charts.humidity) {
                    appState.charts.humidity.options.animation = false;
                    appState.charts.humidity.data.labels = formattedLabels;
                    appState.charts.humidity.data.datasets[0].data = appState.predictions.humidityData;
                    appState.charts.humidity.update();
                }
                
                // Light chart - prepare data
                if (appState.charts.light) {
                    appState.charts.light.options.animation = false;
                    appState.charts.light.data.labels = formattedLabels;
                    appState.charts.light.data.datasets[0].data = appState.predictions.lightData;
                    appState.charts.light.update();
                }
            } catch (error) {
                console.error("Error updating charts:", error);
                addLogEntry("Failed to update charts: " + error.message);
            }
        }

        // Add log entry
        function addLogEntry(message, isAlert = false) {
            const currentTime = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'});
            
            // Create log entry element
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            
            const timestamp = document.createElement('span');
            timestamp.className = 'log-timestamp';
            timestamp.textContent = `[${currentTime}] `;
            logEntry.appendChild(timestamp);
            
            const messageSpan = document.createElement('span');
            messageSpan.textContent = message;
            
            if (isAlert) {
                messageSpan.className = 'log-alert';
            }
            
            logEntry.appendChild(messageSpan);
            
            // Add to container
            elements.logContainer.appendChild(logEntry);
            
            // Scroll to bottom
            elements.logContainer.scrollTop = elements.logContainer.scrollHeight;
            
            // Limit the number of log entries (keep last 100)
            while (elements.logContainer.children.length > 100) {
                elements.logContainer.removeChild(elements.logContainer.firstChild);
            }
        }

        // Helper functions
        function formatDate(date) {
            return date.toLocaleString([], {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }

        function formatTime(date) {
            return date.toLocaleTimeString([], {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }

        // Event listeners
        function setupEventListeners() {
            // Power button
            elements.powerBtn.addEventListener('click', toggleSystem);
            
            // Threshold sliders
            elements.tempSlider.addEventListener('input', () => {
                const value = parseFloat(elements.tempSlider.value);
                appState.thresholds.temperature = value;
                elements.tempValue.textContent = `${value.toFixed(1)} °C`;
            });
            
            elements.humiditySlider.addEventListener('input', () => {
                const value = parseFloat(elements.humiditySlider.value);
                appState.thresholds.humidity = value;
                elements.humidityValue.textContent = `${value.toFixed(1)} %`;
            });
            
            elements.lightSlider.addEventListener('input', () => {
                const value = parseFloat(elements.lightSlider.value);
                appState.thresholds.light = value;
                elements.lightValue.textContent = `${value.toFixed(1)} Lux`;
            });
            
            // Forecast duration dropdown
            elements.forecastDuration.addEventListener('change', () => {
                appState.system.forecastMinutes = parseInt(elements.forecastDuration.value);
            });
            
            // Forecast interval dropdown
            elements.forecastInterval.addEventListener('change', () => {
                appState.system.forecastInterval = parseInt(elements.forecastInterval.value);
                
                // If system is on, restart monitoring with new interval
                if (appState.system.power) {
                    stopMonitoring();
                    startMonitoring();
                }
            });
            
            // Apply button
            elements.applyBtn.addEventListener('click', () => {
                saveSettings();
                applySettings();
            });
            
            // Restore defaults button
            elements.restoreBtn.addEventListener('click', restoreDefaultSettings);
        }

        // Initialize app
        // Add this to your initApp function:
        function initApp() {
            try {
                addLogEntry("Application started");
                
                // Load saved settings
                loadSettings();
                
                // Try to initialize charts, but continue if there's an error
                try {
                    registerChartPlugins();
                    initCharts();
                } catch (e) {
                    console.error("Chart initialization failed:", e);
                    addLogEntry("Chart initialization failed, but application will continue");
                }
                
                // Setup event listeners
                setupEventListeners();
                
                // Initial connection check
                checkConnection();
                
                // Start health checks
                checkSystemHealth();
                setInterval(checkSystemHealth, 5000);
            } catch (e) {
                console.error("Application initialization error:", e);
            }
        }

        // Start the app once DOM is loaded
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>